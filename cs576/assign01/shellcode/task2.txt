task2.txt
I pledge my honor that I have abided by the Stevens Honor System.
Justin Ho

Building off of the original passwd-1.S file, there are several changes made in this extension, particularly in the implementation of the reading and writing of /etc/passwd's contents. Specifically, I edited many of the register references and operations from the 64-bit variants to the 32-bit variants with the initial intent to make the machine code built from this file small enough to fit the attack space in vuln_prog1.bin's complex_verify() function; these edits are now unnecessary since I moved the attack space to below complex_verify()'s return address, giving a large enough space to not worry about the length of the compiled shellcode (the remaining 64-bit references are necessary as their 32-bit counterparts have adverse effects on the attack, like causing segmentation faults). I also slightly adjusted the order of the instructions in the read call to optimize the new looping instructions introduced.

Before the shellcode reaches the new .read section, the buffer size has changed from 32 bytes to 1 byte; this is to ensure that every byte is read from the file. Additionally, I added a reference to %r8d; this register's purpose is to hold /etc/passwd's file descriptor. In the new .read section (whose purpose is to facilitate looping), I then moved the instructions that set %edi to the /etc/passwd file descriptor and that set the %eax register to the read call number. After the syscall instruction, the shellcode takes advantage of the return value of read: it tests if read returns 0, and if it does, the shellcode jumps to the new .exit section, which jumps to the exit syscall. Similar to the problem encountered in passwd-1 regarding vuln_prog2.bin, the new je instruction saw problems due to its offset to the .exit section. Specifically, to jump to the .exit section, it initially needed to jump to an offset of 0x0c, which resulted in a \x0c character, which also stops execution of scanf(). To fix this, I added a filler instruction to make the offset 0x0e, which does not stop scanf().

In regards to the write syscall, it itself was not changed, but directly after the syscall, there is a new jmp instruction to .read, which serves as the looping instruction.
